#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pkcs12.h>
#include <openssl/modes.h>


#include "twofish.h"
#include "legacy.h"
static const EVP_MD * _get_hash(int n);

/* from openssl/crypto/pkcs12/pkcs12.h */

#define PKCS12_KEY_ID   1
#define PKCS12_IV_ID    2


foo_t  pkcs12_pbe_crypt(int pbe_nid, char *password, int passlen, char* salt, int saltlen, int iter, char *in, int inlen, int op) {

	foo_t f;
	f.sz = -1;
	f.data = NULL;
	X509_ALGOR *pbe;


	/* 900 = Twofish with key, iv generated by PKCS12 KDF */
	if (pbe_nid == 900) {

		char key[32];
		char ivec[16];
		char padding[16];
		Twofish_key xkey;
		int padlen;

		PKCS12_key_gen_asc(password, passlen, salt,
				   saltlen, PKCS12_KEY_ID, iter, 32,
				   key, EVP_sha1());

		PKCS12_key_gen_asc(password, passlen, salt,
				   saltlen, PKCS12_IV_ID, iter, 16,
				   ivec, EVP_sha1());

		Twofish_initialise();
		Twofish_prepare_key(key, 32, &xkey);

		f.sz = inlen;
		f.data = malloc(inlen+16);
		if (op) {
			padlen = 16-inlen%16;
			CRYPTO_cbc128_encrypt(in, f.data, inlen-inlen%16, &xkey, ivec, Twofish_encrypt);

			memcpy(padding, in+16*(inlen/16), inlen%16);
			memset(padding+inlen%16, padlen, padlen);
			
			CRYPTO_cbc128_encrypt(padding, f.data+16*(inlen/16), 16, &xkey, ivec, Twofish_encrypt);

			f.sz += padlen;
		} else {
			CRYPTO_cbc128_decrypt(in, f.data, inlen, &xkey, ivec, Twofish_decrypt);

			f.sz -= *(f.data + inlen-1);
		}
		return f;
	}
	
	pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
	if (!pbe) {
		goto err;
	}
	if (!PKCS12_pbe_crypt(pbe, password, passlen, in, inlen, &(f.data), &(f.sz), op)) {
		f.sz = -2;
	}

 err:
	return f;
}

static const EVP_MD * _get_hash(int n) {

	switch(n) {
	case 0:
		return EVP_sha1();
		break;
	case 1:
		return EVP_sha256();
		break;
	case 2:
		return EVP_sha384();
		break;
	case 3:
		return EVP_sha512();
		break;
	case 4:
		return EVP_sha224();
		break;
	default:
		return EVP_sha1();
		break;
	}
}

foo_t  pkcs12_kdf(int hash, char *password, int passlen, char* salt, int saltlen, int id, int iter, int n) {

	foo_t f;
	f.sz = -1;
	f.data = malloc(n);

	if (!PKCS12_key_gen_asc(password, passlen, salt,
				saltlen, id, iter, n,
				f.data, _get_hash(hash))) {
		f.data = NULL;
		goto err;
	}
	f.sz = n;
 err:
	return f;
}
